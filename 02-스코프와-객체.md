비동기적 코드를 다루기 전에 몇 가지 자바스크립트 기본 개념들에 대해 짚고 넘어가보자.

> 스코프, 객체 생성, 구조분해할당
>

<br>

# 스코프

파일 기반 범위 지정은 Node.js에서만 가능하다. 한편 브라우저와 Node.js에 모두 적용할 수 있는 다양한 형태의 범위들이 있다.

프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리할 수 있다. 변수는 전역 또는 코드 블록(if, for, while, try/catch 등)이나 함수 내에 선언하며 코드 블록이나 함수는 중첩될 수 있다. 식별자는 자신이 어디에서 선언됐는지에 의해 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다. [출처: poimaweb](https://poiemaweb.com/js-scope)

## 지역 스코프

### 코드블록

`if`, `for`, `while`, `try/catch` 등

```jsx
const fs = require('fs');

function readFile() {
  try {
    const fileData = fs.readFileSync('data.json');
  } catch (err) {
    console.log('An error occurred.'); // An error occurred.
  }
  console.log(fileData); // ReferenceError: fileData is not defined
}

readFile();
```

`fileData`가 `try 코드블록` 내에서 선언되었기 때문에 `try 코드블록`을 벗어나면 정의되지 않는다. 따라서 `console.log(fileData)`에서 `ReferenceError`가 발생한다.

```jsx
const fs = require('fs');

function readFile() {
  let fileData;
  try {
    fileData = fs.readFileSync('data.json');
  } catch (err) {
    console.log('An error occurred.'); // An error occurred.
  }
  console.log(fileData); // undefined
}

readFile();
```

`fileData`가 `readFile 함수` 범위에서 선언되었기 때문에 함수 내부에서는 어디든지 참조할 수 있고, `try 코드블록` 내에서도 사용할 수 있다. 따라서 에러는 발생하지 않고, `console.log(fileData)`는 `undefined`가 출력된다.

### 섀도잉

> 같은 이름의 변수가 두 개 이상의 스코프에 존재할 때, 더 내부에 있는 스코프의 변수가 바깥쪽 스코프의 변수를 가리는 현상
> 

```jsx
const fs = require('fs');

function readFile() {
  let fileData;
  try {
    const fileData = fs.readFileSync('data.json');
  } catch (err) {
    console.log('An error occurred.'); // An error occurred.
  }
  console.log(fileData); // undefined
}

readFile();
```

`console.log(fileData)`는 `try 블록` 안의 `const fileData`가 아닌, `readFile` 함수 범위에서 선언된 `let fileData`를 참조한다.

<br>
<br>

# 객체의 생성

```jsx
const job = {
  title: "Developer",
  location: "New York",
  salary: 50000
};

console.log(new Date().toString());

const job2 = {
  title: "Cook",
  location: 'Munich',
  salary: 35000,
}
```

## 객체 리터럴

- 중괄호 `{}` 를 이용하여 객체를 직접 생성하는 방법
- `job` : 필요한 곳에서 객체를 만들고 필요한 모든 key-value pair를 수동으로 설명한다.

<br>

## 생성자 함수

- `new Date` : 내장 클래스를 new 연산자를 이용해 생성할 수 있다.

<br>

## class

> *클래스는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다.*
> 
- 객체에 대한 청사진을 정의할 수 있다.
- ES6에서 도입되어 생성자 함수를 좀 더 명확하고 간편하게 정의할 수 있게 되었다.
- class라는 키워드 없이도 클래스 역할을 하는 함수를 선언할 수 있기 때문에 클래스는 편의 문법에 불과하다는 의견도 존재한다.
    
    > 편의 문법(*문법적 설탕*) : 기능은 동일하나 기존 문법을 쉽게 읽을 수 있게 만든 문법
    > 

### constructor 프로퍼티

- 클래스를 기반으로 하는 새 객체가 생성될 때 실행되는 로직을 작성할 수 있다.

```jsx
class Job {
  constructor(title, location, salary) { // constructor: 구체적 인스턴스를 생성하는 메서드, 생성자 함수 역할
    this.title = title; // this: 이 클래스를 기반으로 생성될 객체
    this.location = location;
    this.salary = salary;
  }
}

const developer = new Job('Developer', 'New York', 50000); // 순서대로 입력
const cook = new Job('Cook', 'Munich', 35000);
```

- `this` : 해당 클래스를 기반으로 생성될 객체를 참조한다는 의미

### 메서드

```jsx
class Job {
  constructor(title, location, salary) { // constructor: 구체적 인스턴스를 생성하는 메서드, 생성자 함수 역할
    this.title = title; // this: 생성될 객체를 참조
    this.location = location;
    this.salary = salary;
  }

  decribe() {
    console.log(`I'm a ${this.title}, I work in ${this.location} and I earn ${this.salary}.`)
  }
}

const developer = new Job('Developer', 'New York', 50000); // 순서대로 입력
const cook = new Job('Cook', 'Munich', 35000);

developer.decribe(); //I'm a Developer, I work in New York and I earn 50000.
cook.decribe(); // I'm a Cook, I work in Munich and I earn 35000.
```

- class를 이용해서 생성한 객체도 객체 리터럴 방식으로 얻은 것과 동일한 종류의 객체이다.
    - 객체 리터럴 방식으로 객체를 생성할 때처럼 key-value pair를 일일이 복붙할 필요가 없다. 이러한 과정에서 오타 등으로 오류가 발생하기 쉬운데, class를 통해 객체를 생성하게 되면 오타와 오류의 가능성을 줄여준다.

<br>
<br>

# 배열과 객체의 디스트럭쳐링(구조분해할당)

디스트럭쳐링은 배열, 객체를 파괴하는 것이 아니다 (ㅋㅋ)

기존 배열, 객체는 그대로 존재하지만 거기에서 값을 추출해서 상수나 변수에 할당한다는 것이다.

## 배열

```jsx
const input = ['Max', 'Schwarzmüller'];

// const firstName = input[0];
// const lastName = input[1];
const [firstName, lastName] = input; // 구조분해할당
```

`const firstName = input[0]` 처럼 하나하나 할당하는 것보다 더 빠르고 간편하게 할당할 수 있다.

위의 예시처럼 모든 값을 추출할 필요는 없다. 필요한 경우 일부분 값만 추출할 수도 있다.

## 객체
```js
const job = { title: 'Developer', location: 'New York' };
const { title } = job;
const { location: place } = job;
console.log(place) // New York
```

title과 location을 각각 구조분해할당 한 것처럼 일부 값만 추출할 수도 있다.

또한 location을 place라는 이름으로 추출하는 것처럼 구조분해할당으로 추출한 값에 다른 상수 또는 변수명을 할당해줄 수도 있다.

<br>
<br>