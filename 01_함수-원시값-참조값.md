# More on Functions & Working with Objects/Arrays

## 매개변수의 default값 부여하기

<img src="https://github.com/xoxojw/100-days-of-web-development/assets/124491335/425bc6c7-88f5-465c-886f-234cffb9af1e" width="50%" />

함수의 매개변수에 기본값을 설정해두면, 함수에 매개변수를 전달하지 않을 때는 그 기본값을, 매개변수를 전달할 때는 전달한 값이 기본값을 덮어쓴다.

함수의 매개변수를 나열할 때는 기본값이 없는 비선택적 매개변수를 먼저 나열하고 그 이후에 선택적 매개변수를 나열해야한다.

```jsx
// function greetUser(userName = 'user', greetingPrefix) { // NOT
function greetUser(greetingPrefix, userName = 'user') {
  console.log(`${greetingPrefix}, ${userName}!`);
}

greetUser('Hi', 'Max');
greetUser('Hello');
```

<br>

## 나머지 매개변수, 스프레드 연산자

```jsx
function sumUp1(numbers) {
  let result = 0;

  for (const number of numbers) {
    result += number;
  }

  return result;
}

console.log(sumUp([1, 5, 10, 11, 20, 31])); // 기본적으로 배열의 형태로 넘긴다.
```

```jsx
function sumUp2(...numbers) {
  let result = 0;

  for (const number of numbers) {
    result += number;
  }

  return result;
}

console.log(sumUp(1, 5, 10, 11, 20, 31)); // 배열의 형태로 넘기지 않아도 ... 연산자에 의해 배열로 병합된다
```

- 위의 `sumUp1` 함수의 경우 numbers를 매개변수로 넘겨줄 때 배열의 형태로 데이터를 전달한다.
- 하지만 아래 `sumUp2`의 경우 나머지 매개변수 `…` 연산자를 사용하면 매개변수를 배열이 아닌 쉼표로 구분해 전달하고, 이를 자바스크립트 `내부에서 자동으로 배열로 병합`한다.

```jsx
function sumUp(...numbers) { // 매개변수에 스프레드 연산자 사용
  let result = 0;

  for (const number of numbers) {
    result += number;
  }

  return result;
}

const inputNumbers = [1, 5, 10, 11, 20, 31]; // 배열

console.log(sumUp(inputNumbers)); // 01,5,10,11,20,31
console.log(sumUp(...inputNumbers)); // 78
```

<br>

## 함수는 객체다.

<img src="https://github.com/xoxojw/100-days-of-web-development/assets/124491335/0fdb563c-9919-40c9-a299-d06da4f15bc7" width="50%" />

<br>
<br>

# Reference vs Primitive Values

```jsx
const hobbies = ['Sports', 'Cooking'];

hobbies.push('Reading');

console.log(hobbies) // Sports, Cooking, Reading
```

왜 `const`는 등호를 사용해 새 값을 할당하는지에 대해서만 신경쓰는 것일까? `push`로 내부 값은 변경이 가능한데 말이다.

> 💡 원시 타입과 참조 타입의 가장 큰 차이점 : **변경 가능 여부**
> 원시 타입 : 변경 불가능(immutable) / 참조 타입 : 변경 가능(mutable)

<br>

## 메모리

프로그램이 실행될 때 메모리의 영역은 네 가지로 구분되어 데이터를 저장하고 처리한다.

> 코드 영역, 데이터 영역, 힙 영역, 스택 영역
> 

![image](https://github.com/xoxojw/100-days-of-web-development/assets/124491335/2361d628-1625-4f32-9b8c-c951b4b41123)

[https://velog.io/@averycode/iOS-메모리-구조-Stack-Heap-Data-Code](https://velog.io/@averycode/iOS-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-Stack-Heap-Data-Code)

<br>

## 원시 타입

> numbers, strings, booleans & more (undefined)
> 

<p align="center">
  <img src="https://github.com/xoxojw/100-days-of-web-development/assets/124491335/c79d9ab1-36e1-4d71-a8d7-f767bd7c9a8d" align="center" width="49%"/>
  <img src="https://github.com/xoxojw/100-days-of-web-development/assets/124491335/866f743b-9f08-4436-80e2-815533b93cf3" align="center" width="49%" />
</p>

- 원시 타입의 값은 보다 기본적인 종류의 메모리에 저장된다.
    - 원시 타입의 값은 `스택 영역에 값 자체를 보관`한다.

<br>

## 참조 타입

> Objects ( ⊃ functions, arrays )
> 

객체의 경우 정해진 일정한 사이즈가 없기 때문에 개발자가 선언하는 순간 메모리에 등록되어 관리가 된다.

객체는 개발자가 작성하는 대로 확장이 가능하고, 또 프로퍼티들이 동적으로 변할 수 있다. 따라서 자바스크립트 엔진은 이 객체를 관리하기 위해 얼마만큼의 메모리를 할당해두어야 할지 알 수 없다.

<p align="center">
  <img src="https://github.com/xoxojw/100-days-of-web-development/assets/124491335/30fcea2e-863c-42a5-950b-bd02d6094186" align="center" width="49%"/>
</p>

- 원시값과 다른 종류의 보다 발전된 종류의 메모리에 저장된다. 원시값과는 다른 방식으로 관리한다는 의미이다.
    - 참조 타입의 값들은 `힙 메모리에 객체 인스턴스를 생성`하고, 이 인스턴스가 존재하는 `위치를 스택 메모리에 기록`하여 사용한다.
    - 힙 메모리에 저장되어있는 주소를 스택 영역에 저장해두는 것이다.

<br>

### 예제 1

```jsx
const hobbies = ['Sports', 'Cooking']; // 참조값; 배열의 포인터가 메모리에 저장됨
const age = 20; // 원시값: 값 자체가 메모리에 저장됨

hobbies.push('Reading'); // 배열의 값이 변경되더라도 배열의 주소는 변하지 않음

hobbies = ['Coding', 'Sleeping']; // 불가능

// 상수에는 객체 자체가 아니라 객체의 주소만 저장하기 때문에 상수 값 자체를 조작하지 않고도 기본 객체나 배열 안의 값들을 조작할 수 있는 것
```

<br>

### 예제 2

```jsx
const person = { age: 30 };

// function getAdultYears(p) { // p : 객체의 '주소'
//   p.age -= 18;
//   return p.age
// };

// console.log(getAdultYears(person)); // 12
// console.log("원래 객체의 값", person); // 12 - person 객체의 age값까지 바뀌어버린다.

// 위처럼 person의 age의 원래 값이 변하지 않게 하려면?
// 1) 재정의하지 않고 값으로만 반환하기
function getAdultYears1(p) { // p : 객체의 '주소'
  return p.age - 18;
};
console.log(getAdultYears1(person)); // 12
console.log("원래 객체의 값", person); // 30

// 2) 매개변수에 기존의 person 객체가 아닌 새 객체를 넣어주기
function getAdultYears2(p) {
  p.age -= 18; // 객체 변경
  return p.age;
}
console.log(getAdultYears2({ age: person.age })); // 12 (1) person.age에 저장된 값을 기반으로 새로운 객체 생성
console.log(getAdultYears2({ ...person })); // 12 - (2) 스프레드 연산자 이용하여 객체의 모든 Key-Value 쌍을 가져와 목록을 제공
console.log("원래 객체의 값", person); // 30
```

<br>

> 원시 값과 참조 값이 어떻게 메모리에 저장되어 있는지에 대한 내용은 아래의 블로그에 정말 쉽고 자세하게 정리되어 있다!
> 
> 
> [03. 원시 값과 객체는 메모리에 어떻게 저장되는가? 객체의 복제란?](https://ji-u.tistory.com/21)
> 

<br>
<br>